#include <iostream>
#include <xmmintrin.h>
#include <experimental/filesystem>
#include "../Parallelization/Threading/ThreadPool.h"
#include <vector>
#include <chrono>
#include <list>
#include <fstream>
#include <unordered_map>

namespace fs = std::experimental::filesystem;

static int allocated = 0;
static int deAllocated = 0;

enum test
{
    a = 1 << 0,
    b = 1 << 1,
    c = 1 << 2,
    d = 1 << 3,
};

enum test2
{
    s,
    f,
    g,
    count2
};

class base
{
    public:
        ThreadPool pool;
};

class testclass : public base
{
    public:
    ~testclass()
    {
        std::cout << "In destructor" << std::endl;
        for(auto& el : vect)
        {
            delete el;
        }
    }
    testclass()
    {
        vect.reserve(10000000);
        for(int i = 0; i < 10000000; ++i)
        {
            vect.push_back(new int(i));
        }
        std::cout << unsigned(pool.getThreadCount()) << std::endl;

    }
        // int* p;
        // testclass(int num)
        // {
        //     p = new int(num);
        //     pool = new ThreadPool();
        // }

        // testclass(){}

        // inline int* getnum()
        // {
        //     int* t = p;
        //     p = new int(1);
            
        //     return t;
        // }

        unsigned getThread()
        {
            return pool.getThreadCount();
        }

        std::vector<int*> vect;
};


// void* operator new(size_t size)
// {
//     allocated += size;
//     std::cout << "Allocating: " << size << std::endl;
//     return malloc(size);
// }

// void operator delete(void* memory, size_t size)
// {
//     deAllocated += size;
//     std::cout << "Freeing: " << size << std::endl;
//     free(memory);
// }

void test(testclass& t)
{
    std::cout << "Do nothing" << std::endl;
}

        struct Node
        {
            std::unordered_map<char, std::unique_ptr<Node>> charMap;
            bool isWord = false;
        };

std::vector<std::unique_ptr<Node>> te()
{
    std::vector<std::unique_ptr<Node>> vec;
    vec.emplace_back(std::make_unique<Node>());
    vec.emplace_back(std::make_unique<Node>());
    vec[1]->isWord = true;
    return vec;
}

#include "../Datastructures/Trie.h"

int main()
{

    std::vector<std::unique_ptr<Node>> vect = te();
    for(auto& a : vect)
    {
        std::cout << a->isWord << std::endl;
    }
    // std::string test = "hello";
    // std::string test1 = "hello2";
    
    // Trie t;
    
    // t.insert(test);
    // std::cout << (t.search("Hello")  ? "True" : "False")<< std::endl;
    // std::cout << (t.search(test1) ? "True" : "False") << std::endl;

    // t.insert(test1);
    // std::cout << (t.search("hello2")  ? "True" : "False") << std::endl;

    // t.remove(test1);

    // std::cout << (t.search("hello2")  ? "True" : "False") << std::endl;

    return 0;


}