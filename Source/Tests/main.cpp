#include <iostream>
#include <xmmintrin.h>
#include <experimental/filesystem>
#include "../Parallelization/Threading/ThreadPool.h"
#include <vector>
#include <chrono>
#include <list>
#include <fstream>

namespace fs = std::experimental::filesystem;

static int allocated = 0;
static int deAllocated = 0;

enum test
{
    a = 1 << 0,
    b = 1 << 1,
    c = 1 << 2,
    d = 1 << 3,
};

enum test2
{
    s,
    f,
    g,
    count2
};

class base
{
    public:
        ThreadPool pool;
};

class testclass : public base
{
    public:
    ~testclass()
    {
        std::cout << "In destructor" << std::endl;
        for(auto& el : vect)
        {
            delete el;
        }
    }
    testclass()
    {
        vect.reserve(10000000);
        for(int i = 0; i < 10000000; ++i)
        {
            vect.push_back(new int(i));
        }
        std::cout << unsigned(pool.getThreadCount()) << std::endl;

    }
        // int* p;
        // testclass(int num)
        // {
        //     p = new int(num);
        //     pool = new ThreadPool();
        // }

        // testclass(){}

        // inline int* getnum()
        // {
        //     int* t = p;
        //     p = new int(1);
            
        //     return t;
        // }

        unsigned getThread()
        {
            return pool.getThreadCount();
        }

        std::vector<int*> vect;
};


// void* operator new(size_t size)
// {
//     allocated += size;
//     std::cout << "Allocating: " << size << std::endl;
//     return malloc(size);
// }

// void operator delete(void* memory, size_t size)
// {
//     deAllocated += size;
//     std::cout << "Freeing: " << size << std::endl;
//     free(memory);
// }


int main()
{

    testclass c;
    std::cout << c.getThread() << std::endl;
    return 0;
    // std::vector<std::ofstream> fileVector;
    // fileVector.emplace_back(std::ofstream("test.txt"));
    // fileVector.emplace_back(std::ofstream("test1.txt"));

    // if(fileVector[0].is_open() || fileVector[1].is_open()){
    //     std::cout << "They are both open" << std::endl;
    // }
    // std::cout << sizeof(fileVector[0]) << " " <<  sizeof(fileVector[1]) << std::endl;

    // for(auto& el : fileVector)
    //     el.close();
    // ThreadPool pool;
    // pool.push([](){std::cout << "Hello from threadpool lambda";});
    // std::cout << test::a << std::endl;
    // std::cout << test::b << std::endl;
    // std::cout << test::c << std::endl;
    // std::cout << test::d << std::endl;

    // std::cout << (1 << (sizeof(test)-1)) << std::endl;
    // testclass* c;
    // c = new testclass;
    // // int* p = c.getnum();
    // // std::cout << c.getThread() << std::endl;
    // //std::cout << *p << std::endl;
    // //std::cout << *c.getnum() << std::endl;

    // c->vect.push_back(new int(5));
    // c->vect.push_back(new int(6));
    // c->vect.push_back(new int(7));
    // c->vect.push_back(new int(8));
    // c->vect.push_back(new int(9));
    // c->vect.push_back(new int(10));

    // delete c;
//    {
        // std::vector<testclass> c;
        // for(int i = 0; i < 10; ++i)
        // {
        //     c.emplace_back(testclass());
        // }
 //       testclass c;
//    }
//    std::cout << "Total Allocated: " << allocated << std::endl;
 //   std::cout << "Total De-Allocated: " << deAllocated << std::endl;


}