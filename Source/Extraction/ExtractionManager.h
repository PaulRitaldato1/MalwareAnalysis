#pragma once

#include "../Parallelization/Threading/ThreadPool.h"
#include "IFile.h"
#include "FileFactory.h"
#include <string>
#include <vector>
#include <filesystem>

namespace Extractor
{
            
            std::vector<std::string> getFilenamesFromDirectory(std::string& fileDirectory)
            {
                std::vector<std::string> retVec;
                for(auto& file : std::filesystem::directory_iterator(fileDirectory) )
                {
                    std::cout << file.path().string() << std::endl;
                    retVec.emplace_back(file.path().string());
                }
                return retVec;
            }

            std::vector<std::shared_ptr<IFile>> buildFileList(DirectoryDesc& directory)
            {
                std::vector<std::string> fileNames = getFilenamesFromDirectory(directory.path);
                
                FileFactory fileFactory;
                std::vector<std::shared_ptr<IFile>> retVec;
                
                for(const auto& file : fileNames)
                {
                    FileDesc desc;
                    desc.fileName = file;
                    desc.isMalicious = directory.isMalicious;
                    desc.mask = directory.mask;
                    
                    std::shared_ptr<IFile> temp = fileFactory.makeFile(desc);
                    
                    //check to make sure a valid file was found
                    if(temp != nullptr)
                        retVec.emplace_back(temp);
                }
                return retVec;
            }

            std::vector<std::shared_ptr<FeatureSet>> extractFromDirectory(std::string& fileDirectory, FeatureMask mask, bool isMaliciousDirectory)
            {
                ThreadPool pool;
                //set up extractors
                DirectoryDesc directory;
                directory.path = fileDirectory;
                directory.mask = mask;
                directory.isMalicious = isMaliciousDirectory;

                std::vector<std::shared_ptr<IFile>> files = buildFileList(directory);
                std::vector<std::future<std::shared_ptr<FeatureSet>>> featureSetFutures;
                
                //extract
                for(std::shared_ptr<IFile>& ex : files)
                {
                    auto func = std::bind(&IFile::extractFeatures, ex);// need to bind member functions before pushing to the pool
                    featureSetFutures.emplace_back(pool.push(func));
                }
                 
                //wait for all the features to be extracted
                std::vector<std::shared_ptr<FeatureSet>> featuresExtracted;
                for(auto& future : featureSetFutures)
                    featuresExtracted.emplace_back(future.get());

                return featuresExtracted;  
            }

}