#pragma once

#include "../Parallelization/Threading/ThreadPool.h"
#include "IFile.h"
#include "FileFactory.h"
#include <string>
#include <vector>

namespace fs = std::experimental::filesystem;

namespace Extractor
{

            std::vector<FeatureSet> extractFromDirectory(std::string& fileDirectory, FeatureMask mask, bool isMaliciousDirectory)
            {
                ThreadPool pool;
                //set up extractors
                std::vector<IFile*> files = buildFileList(fileDirectory, mask, isMaliciousDirectory);
                std::vector<std::future<FeatureSet>> featureSetFutures;
                //extract
                for(auto& ex : files)
                    featureSetFutures.emplace_back(pool.push(ex->extractFeatures()));
                 
                //wait for all the features to be extracted
                std::vector<FeatureSet> featuresExtracted;
                for(auto& future : featureSetFutures)
                    featuresExtracted.emplace_back(future.get());

                return featuresExtracted;  
            }

            std::vector<IFile*> buildFileList(std::string& fileDirectory, FeatureMask mask, bool isMalicious)
            {
                std::vector<std::string> fileNames = getFilenamesFromDirectory(fileDirectory);
                FileFactory fileFactory;
                std::vector<IFile*> retVec;
                for(const auto& file : fileNames)
                {
                    FileDesc desc;
                    desc.fileName = file;
                    desc.maliciousness = isMalicious;
                    desc.mask = mask;
                    retVec.emplace_back(fileFactory.makeFile(desc));
                }
            }
            
            std::vector<std::string> getFilenamesFromDirectory(std::string& fileDirectory)
            {
                std::vector<std::string> retVec;
                for(const auto& file : fs::directory_iterator(fileDirectory) )
                {
                    retVec.emplace_back(file.path());
                }
                return retVec;
            }
}