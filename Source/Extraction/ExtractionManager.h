#pragma once

#include "../Parallelization/Threading/ThreadPool.h"
#include "IFile.h"
#include "FileFactory.h"
#include <string>
#include <vector>

namespace fs = std::experimental::filesystem;

namespace Extractor
{
            struct DirectoryDesc
            {
                std::string path;
                FeatureMask mask;
                bool isMalicious;
            };

            std::vector<std::unique_ptr<FeatureSet>> extractFromDirectory(std::string& fileDirectory, FeatureMask mask, bool isMaliciousDirectory)
            {
                ThreadPool pool;
                //set up extractors
                DirectoryDesc directory;
                directory.path = fileDirectory;
                directory.mask = mask;
                directory.isMalicious = isMaliciousDirectory;

                std::vector<std::unique_ptr<IFile>> files = buildFileList(directory);
                std::vector<std::future<std::unique_ptr<FeatureSet>>> featureSetFutures;
                
                //extract
                for(auto& ex : files)
                    featureSetFutures.emplace_back(pool.push(ex->extractFeatures()));
                 
                //wait for all the features to be extracted
                std::vector<std::unique_ptr<FeatureSet>> featuresExtracted;
                for(auto& future : featureSetFutures)
                    featuresExtracted.emplace_back(future.get());

                return featuresExtracted;  
            }

            std::vector<std::unique_ptr<IFile>> buildFileList(DirectoryDesc& directory)
            {
                std::vector<std::string> fileNames = getFilenamesFromDirectory(directory.path);
                
                FileFactory fileFactory;
                std::vector<std::unique_ptr<IFile>> retVec;
                
                for(const auto& file : fileNames)
                {
                    FileDesc desc;
                    desc.fileName = file;
                    desc.maliciousness = directory.isMalicious;
                    desc.mask = directory.mask;
                    
                    std::unique_ptr<IFile> temp = fileFactory.makeFile(desc);
                    
                    //check to make sure a valid file was found
                    if(temp != nullptr)
                        retVec.emplace_back(std::move(temp));
                }
                return retVec;
            }
            
            std::vector<std::string> getFilenamesFromDirectory(std::string& fileDirectory)
            {
                std::vector<std::string> retVec;
                for(const auto& file : fs::directory_iterator(fileDirectory) )
                {
                    retVec.emplace_back(file.path());
                }
                return retVec;
            }
}