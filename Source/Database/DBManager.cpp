#include "DBManager.h"
#include "../global/Macros.h"
#include <array>
namespace DB
{
    DBManager::DBManager()
    {
        // const char*  query = "SELECT name FROM sqlite_master WHERE type='table' AND name='?';";

        std::array<std::string, 4> schema = {
            "CREATE TABLE IF NOT EXISTS NGram("
                "ngid INTEGER PRIMARY_KEY,"
                "ngram TEXT NOT NULL,"
                "string_hash INTEGER NOT NULL"
            ");",

            "CREATE TABLE IF NOT EXISTS File("
                "fid INTEGER PRIMARY KEY,"
                "name TEXT UNIQUE NOT NULL,"
                "hash INTEGER NOT NULL,"
                "type TEXT CHECK(type IN ('pe32', 'pe32+', 'elf')) NOT NULL,"
                "date_added DATE,"
                "is_malicious BOOLEAN NOT NULL,"
                "virtual_size INTEGER NOT NULL,"
                "num_exe_sections INTEGER NOT NULL,"
                "num_sections INTEGER NOT NULL,"
                "vr_ratio REAL NOT NULL,"
                "LoadLibraryA BOOLEAN NOT NULL,"
                "GetProcAddress BOOLEAN NOT NULL,"
                "VirtualFree BOOLEAN NOT NULL,"
                "LocalFree BOOLEAN NOT NULL,"
                "SetLastError BOOLEAN NOT NULL,"
                "RegCloseKey BOOLEAN NOT NULL"
            ");",

            "CREATE TABLE IF NOT EXISTS FileNGrams("
                "fid INTEGER,"
                "ngid INTEGER,"
                "PRIMARY KEY (fid, ngid),"
                "FOREIGN KEY (fid)"
                    " REFERENCES File (fid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION,"
                "FOREIGN KEY (ngid)"
                    " REFERENCES NGram (ngid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION"
            ");",

            "CREATE TABLE IF NOT EXISTS FilteredNGrams("
                "ngid INTEGER,"
                "PRIMARY KEY(ngid)"
                "FOREIGN KEY (ngid)"
                    " REFERENCES NGram(ngid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION"
            ");"
        };
        char* error = nullptr;
        int returnCode = sqlite3_open("/mnt/c/Users/paulr/Documents/Malware-Detector  V2/Data/Database/Malware.db", &connection);
        if(returnCode) 
        {
            fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(connection));
            std::terminate();
        }
        else 
        {
            fprintf(stdout, "Opened database successfully\n");
        }

        FATAL_ASSERT(returnCode == 0, "DB::DBManager::DBManager: Failed to open database connection!");

        for(auto& table : schema)
        {
            returnCode = sqlite3_exec(connection, table.c_str(), NULL, 0, &error);
            if(!checkReturnCode(returnCode, error))
            {
                throw std::runtime_error("Failed to create table: " + table);
            }
        }
    }

    bool DBManager::insertFile(Extractor::FeatureSet& features)
    {

    }

    Extractor::FeatureSet DBManager::queryFile(std::string name)
    {
        
        sqlite3_stmt* stmt = nullptr;

        int rc = sqlite3_prepare_v2(connection, "SELECT * FROM File WHERE name = ?", -1, &stmt, 0);
        //rc = sqlite3_exec(connection, "BEGIN TRANSACTION", 0, 0, 0);
        rc = sqlite3_bind_text(stmt, 1, name.c_str(), -1, NULL);
        rc = sqlite3_step(stmt);
        //construct FeatureSet object
        Extractor::FeatureSet set;
        if(rc == SQLITE_ROW)
        {

            set.filename = static_cast<std::string>(sqlite3_column_text(stmt, 1));
            set.fileHash = static_cast<std::size_t>(sqlite3_column_int(stmt, 2));
            set.numExeSections = static_cast<std::uint16_t>(sqlite3_column_int(stmt, 7));
            set.numSections = static_cast<std::uint16_t>(sqlite3_column_int(stmt, 8));
            set.virtualTextSizeRatio = sqlite3_column_double(stmt, 9);
            set.isMalicious = sqlite3_column_int(stmt, 5);
        }
        else
        {
            set.filename = "INVALID";
        }
        
        //rc = sqlite3_exec(connection, "END TRANSACTION", 0, 0, 0);
        rc = sqlite3_finalize(stmt);

        return set;
    }

    bool DBManager::checkReturnCode(int returnCode, char* error)
    {
        if(returnCode != SQLITE_OK )
        {
            if(error)
                fprintf(stderr, "SQL error: %s\n", error);
            else
                std::cout << "SQL error, with no error message." << std::endl;
            
            sqlite3_free(error);
            error = nullptr;
            return false;
        }
        return true;
    }

    DBManager::~DBManager()
    {
        sqlite3_close(connection);
    }

}