#include "DBManager.h"
#include "../Global/Macros.h"
#include "../Extraction/FileFactory.h"
#include <array>
#include <unordered_map>

namespace DB
{
    DBManager::DBManager()
    {
        const std::array<std::string, 5> schema = {
            "CREATE TABLE IF NOT EXISTS NGrams("
                "ngid INTEGER PRIMARY KEY,"
                "ngram TEXT UNIQUE NOT NULL,"
                "string_hash INTEGER NOT NULL,"
                "frequency INTEGER NOT NULL,"
                "type TEXT CHECK(type IN ('X86')) NOT NULL,"
                "size INTEGER NOT NULL"
            ");",

            "CREATE TABLE IF NOT EXISTS Files("
                "fid INTEGER PRIMARY KEY,"
                "shortname TEXT UNIQUE NOT NULL,"
                "filepath TEXT UNIQUE NOT NULL,"
                "hash INTEGER NOT NULL,"
                "type TEXT CHECK(type IN ('PE32', 'PE32_PLUS', 'ELF')) NOT NULL,"
                "date_added DATE,"
                "is_malicious BOOLEAN NOT NULL,"
                "virtual_size INTEGER NOT NULL,"
                "num_exe_sections INTEGER NOT NULL,"
                "num_sections INTEGER NOT NULL,"
                "vr_ratio REAL NOT NULL,"
                "LoadLibraryA BOOLEAN NOT NULL,"
                "GetProcAddress BOOLEAN NOT NULL,"
                "VirtualFree BOOLEAN NOT NULL,"
                "LocalFree BOOLEAN NOT NULL,"
                "SetLastError BOOLEAN NOT NULL,"
                "RegCloseKey BOOLEAN NOT NULL"
            ");",

            "CREATE TABLE IF NOT EXISTS FileNGrams("
                "fid INTEGER,"
                "ngid INTEGER,"
                "PRIMARY KEY (fid, ngid),"
                "FOREIGN KEY (fid)"
                    " REFERENCES File (fid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION,"
                "FOREIGN KEY (ngid)"
                    " REFERENCES NGram (ngid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION"
            ");",

            "CREATE TABLE IF NOT EXISTS FilteredNGrams("
                "ngid INTEGER,"
                "PRIMARY KEY(ngid)"
                "FOREIGN KEY (ngid)"
                    " REFERENCES NGram(ngid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION"
            ");",
            "CREATE TABLE IF NOT EXISTS FileInstructions("
                "fid INTEGER,"
                "instruction TEXT NOT NULL,"
                "PRIMARY KEY (FID),"
                "FOREIGN KEY (FID)"
                    " REFERENCES File(fid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION"
            ");"
        };
        char* error = nullptr;
        int returnCode = sqlite3_open("/home/paul/Atheris/Data/Database/Malware.db", &connection);
        if(returnCode) 
        {
            fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(connection));
            std::terminate();
        }
        else 
        {
            fprintf(stdout, "Opened database successfully\n");
        }

        for(auto& table : schema)
        {
            returnCode = sqlite3_exec(connection, table.c_str(), NULL, 0, &error);
            if(!checkReturnCode(returnCode, error))
            {
                throw std::runtime_error("Failed to create table: " + table);
            }
        }
    }

    bool DBManager::insertFile(Extractor::FeatureSet& features)
    {
        std::unique_lock<std::mutex> lock(dbLock);
        std::string query = "INSERT INTO Files (shortname, filepath, hash, type, is_malicious, virtual_size, num_exe_sections, num_sections, vr_ratio, LoadLibraryA, GetProcAddress, VirtualFree, LocalFree, SetLastError, RegCloseKey)"
                            " VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
        sqlite3_stmt* stmt = nullptr;

        int rc = sqlite3_prepare_v2(connection, query.c_str(), -1, &stmt, nullptr);
        if(rc == SQLITE_OK)
        {
            std::unordered_map<Extractor::filetype, std::string> toString = 
            {
                {Extractor::PE32, "PE32"}, 
                {Extractor::PE32_PLUS, "PE32_PLUS"}, 
                {Extractor::ELF, "ELF"}
            };

            rc = sqlite3_bind_text(stmt, 1, features.shortname.c_str(), -1, NULL);
            rc = sqlite3_bind_text(stmt, 2, features.filepath.c_str(), -1, NULL);
            rc = sqlite3_bind_int(stmt, 3, static_cast<int>(features.fileHash));
            rc = sqlite3_bind_text(stmt, 4, toString[features.type].c_str(), -1, NULL);
            rc = sqlite3_bind_int(stmt, 5, static_cast<int>(features.isMalicious));
            rc = sqlite3_bind_int(stmt, 6, static_cast<int>(features.virtualSize));
            rc = sqlite3_bind_int(stmt, 7, static_cast<int>(features.numExeSections));
            rc = sqlite3_bind_int(stmt, 8, static_cast<int>(features.numSections));
            rc = sqlite3_bind_double(stmt, 9, features.virtualTextSizeRatio);
            for(std::size_t i = Extractor::LoadLibraryA; i < Extractor::FUNCTION_SEARCH_SIZE; ++i)
            {
                sqlite3_bind_int(stmt, i + 10, static_cast<int>(features.functions[i]));
            }

            rc = sqlite3_step(stmt);
            int fid = sqlite3_last_insert_rowid(connection);
            sqlite3_finalize(stmt);
            stmt = nullptr;

            //cache for later
            
            //insert nGrams
            std::unordered_map<Extractor::nGramType, std::string> toEnumNGrams = 
            {
                {Extractor::X86, "X86"}
            };
            
            sqlite3_stmt* stm2;
            std::vector<int> ngids;
            ngids.reserve(features.nGrams.size());
            query = "INSERT INTO NGrams (ngram, string_hash, frequency, type, size)"
                    " VALUES(?, ?, ?, ?, ?);";
            rc = sqlite3_prepare_v2(connection, query.c_str(), -1, &stm2, nullptr);
            for(Extractor::nGram& ngram : features.nGrams)
            {
                rc = sqlite3_bind_text(stm2, 1, ngram.ngram.c_str(), -1, NULL);
                rc = sqlite3_bind_int(stm2, 2, ngram.hash);
                rc = sqlite3_bind_int(stm2, 3, ngram.frequency);
                rc = sqlite3_bind_text(stm2, 4, toEnumNGrams[ngram.type].c_str(), -1, NULL);
                rc = sqlite3_bind_int(stm2, 5, ngram.size);

                rc = sqlite3_step(stm2);
                ngids.push_back(sqlite3_last_insert_rowid(connection));
                rc = sqlite3_clear_bindings(stm2);
                rc = sqlite3_reset(stm2);
            }
            sqlite3_finalize(stm2);
            stm2 = nullptr;

            query = "INSERT INTO FileNGrams (fid, ngid)"
                    " VALUES(?,?);";
            
            sqlite3_stmt* stm3;

            rc = sqlite3_prepare_v2(connection, query.c_str(), -1, &stm3, nullptr);
            for(int& ngid : ngids)
            {
                rc = sqlite3_bind_int(stm3, 1, fid);
                rc = sqlite3_bind_int(stm3, 2, ngid);
                rc = sqlite3_step(stm3);
                rc = sqlite3_clear_bindings(stm3);
                rc = sqlite3_reset(stm3);
            }
            sqlite3_finalize(stm3);
            return true;   
        }
        else
        {
            return false;
        }
        
    }

    //TODO: Delete file
    //Issue: Should ngrams be deleted as well? If not, how would I manage decrementing the frequency of ngrams
    //that belonged to that file?

    std::unique_ptr<Extractor::IFile> DBManager::queryFile(std::string name)
    {        
        std::unique_lock<std::mutex> lock(dbLock);
        sqlite3_stmt* stmt = nullptr;
        std::string query = "SELECT * FROM Files WHERE shortname = ?";
        // char* error;
        // int rc = sqlite3_exec(connection, query.c_str(), NULL, NULL, &error);
        // checkReturnCode(rc, error);
        int rc = sqlite3_prepare_v2(connection, query.c_str(), -1, &stmt, 0);
        //rc = sqlite3_exec(connection, "BEGIN TRANSACTION", 0, 0, 0);

        rc = sqlite3_bind_text(stmt, 1, name.c_str(), -1, NULL);
        rc = sqlite3_step(stmt);

        //construct FeatureSet object
        if(rc == SQLITE_ROW) 
        {   
            std::unordered_map<std::string, Extractor::filetype> toEnum = 
            {
                {"PE32", Extractor::PE32}, 
                {"PE32_PLUS", Extractor::PE32_PLUS}, 
                {"ELF", Extractor::ELF}
            };

            int fid = sqlite3_column_int(stmt, 0);
            //Set up correct file with file factory
            std::unique_ptr<Extractor::IFile> file;
            Extractor::FileFactory factory;
            Extractor::filetype type = toEnum[static_cast<std::string>(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 4)))];
            file = factory.makeFile(type);
            Extractor::FeatureSet set;
            
            //Extract file identifiers 
            set.shortname = static_cast<std::string>(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1)));
            set.filepath = static_cast<std::string>(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2)));
            set.fileHash = static_cast<std::size_t>(sqlite3_column_int(stmt, 3));
            set.type = type;
            set.isMalicious = (unsigned)sqlite3_column_int(stmt, 6);
            
            //Extract section data
            set.virtualSize = (unsigned)sqlite3_column_int(stmt, 7);
            set.numExeSections = (unsigned)sqlite3_column_int(stmt, 8);
            set.numSections = (unsigned)sqlite3_column_int(stmt, 9);
            set.virtualTextSizeRatio = sqlite3_column_double(stmt, 10);

            //extract function bools
            for(std::size_t functionIndex = 11; functionIndex < 17; ++functionIndex)
                set.functions[functionIndex-11]  = static_cast<bool>(sqlite3_column_int(stmt, functionIndex));
            
            rc = sqlite3_finalize(stmt);
            stmt = nullptr;
            //TODO: Should this only return NGrams from the filtered list?
            query = "SELECT NGrams.ngram, NGrams.string_hash, NGrams.frequency, NGrams.type, NGrams.size FROM NGrams INNER JOIN FileNGrams ON FileNGrams.fid = ?";
            rc = sqlite3_prepare_v2(connection, query.c_str(), -1, &stmt, 0);
            rc = sqlite3_bind_int(stmt, 1, fid);
            
            std::unordered_map<std::string, Extractor::nGramType> toEnumNGram = 
            {
                {"X86", Extractor::X86}
            };

            while(sqlite3_step(stmt) == SQLITE_ROW)
            {
                Extractor::nGram ngram;
                ngram.ngram = static_cast<std::string>(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0)));
                ngram.hash = sqlite3_column_int(stmt, 1);
                ngram.frequency = sqlite3_column_int(stmt, 2);
                ngram.type = toEnumNGram[static_cast<std::string>(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 3)))];
                ngram.size = sqlite3_column_int(stmt, 4);
                set.nGrams.emplace_back(ngram);
            }

            file->setFeatures(set);

            return file;
        }
        else
        {
            rc = sqlite3_finalize(stmt);
            return nullptr;
        }
        
        //rc = sqlite3_exec(connection, "END TRANSACTION", 0, 0, 0);
    }
    
    std::unique_ptr<Extractor::nGram> DBManager::queryNGram(std::string& nGramString)
    {
        std::unique_lock<std::mutex> lock(dbLock);

        std::string query = "SELECT * FROM NGrams WHERE ngram = ?";
        sqlite3_stmt* stmt = nullptr;
        int rc = sqlite3_prepare_v2(connection, query.c_str(), -1, &stmt, 0);
        rc = sqlite3_bind_text(stmt, 1, nGramString.c_str(), -1, NULL);
        rc = sqlite3_step(stmt);
        if(rc == SQLITE_ROW)
        { 
            std::unordered_map<std::string, Extractor::nGramType> toEnumNGram = 
            {
                {"X86", Extractor::X86}
            };

            Extractor::nGram ngram;
            ngram.ngram = static_cast<std::string>(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1)));
            ngram.hash = sqlite3_column_int(stmt, 2);
            ngram.frequency = sqlite3_column_int(stmt, 3);
            ngram.type = toEnumNGram[static_cast<std::string>(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 4)))];
            ngram.size = sqlite3_column_int(stmt, 5);
            sqlite3_finalize(stmt);

            return std::make_unique<Extractor::nGram>(ngram);
        }
        else
        {
            sqlite3_finalize(stmt);
            return nullptr;
        }
        
    }

    bool DBManager::insertNGrams(std::vector<Extractor::nGram> ngrams)
    {
            std::unique_lock<std::mutex> lock(dbLock);

            std::unordered_map<Extractor::nGramType, std::string> toEnumNGrams = 
            {
                {Extractor::X86, "X86"}
            };
            
            sqlite3_stmt* stmt;
            std::vector<int> ngids;
            ngids.reserve(ngrams.size());
            std::string query = "INSERT INTO NGrams (ngram, string_hash, frequency, type, size)"
                    " VALUES(?, ?, ?, ?, ?);";
            int rc = sqlite3_prepare_v2(connection, query.c_str(), -1, &stmt, nullptr);
            for(Extractor::nGram& ngram : ngrams)
            {
                rc = sqlite3_bind_text(stmt, 1, ngram.ngram.c_str(), -1, NULL);
                rc = sqlite3_bind_int(stmt, 2, ngram.hash);
                rc = sqlite3_bind_int(stmt, 3, ngram.frequency);
                rc = sqlite3_bind_text(stmt, 4, toEnumNGrams[ngram.type].c_str(), -1, NULL);
                rc = sqlite3_bind_int(stmt, 5, ngram.size);

                rc = sqlite3_step(stmt);
                if(rc != SQLITE_OK)
                {
                    sqlite3_finalize(stmt);
                    return false;
                }

                rc = sqlite3_clear_bindings(stmt);
                rc = sqlite3_reset(stmt);
            }
            sqlite3_finalize(stmt);
            return true;
    }

    bool DBManager::insertNGram(Extractor::nGram ngram)
    {
        std::unique_lock<std::mutex> lock(dbLock);

        std::unordered_map<Extractor::nGramType, std::string> toEnumNGrams = 
        {
            {Extractor::X86, "X86"}
        };

        std::string query = "INSERT INTO NGrams (ngram, string_hash, frequency, type, size)"
                            " VALUES(?,?,?,?,?);";
        sqlite3_stmt* stmt = nullptr;
        int rc = sqlite3_prepare_v2(connection, query.c_str(), -1, &stmt, 0);
        rc = sqlite3_bind_text(stmt, 1, ngram.ngram.c_str(), -1, NULL);
        rc = sqlite3_bind_int(stmt, 2, ngram.hash);
        rc = sqlite3_bind_int(stmt, 3, ngram.frequency);
        rc = sqlite3_bind_text(stmt, 4, toEnumNGrams[ngram.type].c_str(), -1, NULL);
        rc = sqlite3_bind_int(stmt, 5, ngram.size);

        rc = sqlite3_step(stmt);
        if(rc == SQLITE_OK)
        {
            sqlite3_finalize(stmt);
            return true;
        }
        else
        {
            sqlite3_finalize(stmt);
            return false;
        }
        
    }


    bool DBManager::deleteNGram(Extractor::nGram ngram)
    {
        std::unique_lock<std::mutex> lock(dbLock);

        std::string query = "DELETE FROM NGrams WHERE ngram=?";
        sqlite3_stmt* stmt = nullptr; 
        int rc = sqlite3_prepare16_v2(connection, query.c_str(), -1, &stmt, 0);
        rc = sqlite3_bind_text(stmt, 1, ngram.ngram.c_str(), -1, NULL);
        rc = sqlite3_step(stmt);
        
        if(rc == SQLITE_OK)
        {
            sqlite3_finalize(stmt);
            return true;
        }
        else
        {
            sqlite3_finalize(stmt);
            return false;            
        }
    }



    bool DBManager::checkReturnCode(int returnCode, char* error)
    {
        if(returnCode != SQLITE_OK )
        {
            if(error)
                fprintf(stderr, "SQL error: %s\n", error);
            else
                std::cout << "SQL error, with no error message." << std::endl;
            
            sqlite3_free(error);
            error = nullptr;
            return false;
        }
        return true;
    }

    DBManager::~DBManager()
    {
        sqlite3_close(connection);
    }

}