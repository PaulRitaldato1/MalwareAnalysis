#include "DBManager.h"
#include "../global/Macros.h"
#include "../Extraction/IFile.h"
#include "../Extraction/FileFactory.h"
#include <array>
#include <unordered_map>

namespace DB
{
    DBManager::DBManager()
    {
        // const char*  query = "SELECT name FROM sqlite_master WHERE type='table' AND name='?';";

        const std::array<std::string, 4> schema = {
            "CREATE TABLE IF NOT EXISTS NGram("
                "ngid INTEGER PRIMARY_KEY,"
                "ngram TEXT NOT NULL,"
                "string_hash INTEGER NOT NULL"
            ");",

            "CREATE TABLE IF NOT EXISTS File("
                "fid INTEGER PRIMARY KEY,"
                "name TEXT UNIQUE NOT NULL,"
                "hash INTEGER NOT NULL,"
                "type TEXT CHECK(type IN ('PE32', 'PE32_PLUS', 'ELF')) NOT NULL,"
                "date_added DATE,"
                "is_malicious BOOLEAN NOT NULL,"
                "virtual_size INTEGER NOT NULL,"
                "num_exe_sections INTEGER NOT NULL,"
                "num_sections INTEGER NOT NULL,"
                "vr_ratio REAL NOT NULL,"
                "LoadLibraryA BOOLEAN NOT NULL,"
                "GetProcAddress BOOLEAN NOT NULL,"
                "VirtualFree BOOLEAN NOT NULL,"
                "LocalFree BOOLEAN NOT NULL,"
                "SetLastError BOOLEAN NOT NULL,"
                "RegCloseKey BOOLEAN NOT NULL"
            ");",

            "CREATE TABLE IF NOT EXISTS FileNGrams("
                "fid INTEGER,"
                "ngid INTEGER,"
                "PRIMARY KEY (fid, ngid),"
                "FOREIGN KEY (fid)"
                    " REFERENCES File (fid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION,"
                "FOREIGN KEY (ngid)"
                    " REFERENCES NGram (ngid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION"
            ");",

            "CREATE TABLE IF NOT EXISTS FilteredNGrams("
                "ngid INTEGER,"
                "PRIMARY KEY(ngid)"
                "FOREIGN KEY (ngid)"
                    " REFERENCES NGram(ngid)"
                        " ON DELETE CASCADE"
                        " ON UPDATE NO ACTION"
            ");"
        };
        char* error = nullptr;
        int returnCode = sqlite3_open("/mnt/c/Users/paulr/Documents/Malware-Detector  V2/Data/Database/Malware.db", &connection);
        if(returnCode) 
        {
            fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(connection));
            std::terminate();
        }
        else 
        {
            fprintf(stdout, "Opened database successfully\n");
        }

        FATAL_ASSERT(returnCode == 0, "DB::DBManager::DBManager: Failed to open database connection!");

        for(auto& table : schema)
        {
            returnCode = sqlite3_exec(connection, table.c_str(), NULL, 0, &error);
            if(!checkReturnCode(returnCode, error))
            {
                throw std::runtime_error("Failed to create table: " + table);
            }
        }
    }

    bool DBManager::insertFile(Extractor::FeatureSet& features)
    {

    }

    std::unique_ptr<Extractor::IFile> DBManager::queryFile(std::string name)
    {        
        sqlite3_stmt* stmt = nullptr;

        int rc = sqlite3_prepare_v2(connection, "SELECT * FROM File WHERE name = ?", -1, &stmt, 0);
        //rc = sqlite3_exec(connection, "BEGIN TRANSACTION", 0, 0, 0);
        rc = sqlite3_bind_text(stmt, 1, name.c_str(), -1, NULL);
        rc = sqlite3_step(stmt);
        //construct FeatureSet object
        if(rc == SQLITE_ROW)
        {   
            std::unordered_map<std::string, Extractor::filetype> toEnum = 
            {
                {"PE32", Extractor::PE32}, 
                {"PE32_PLUS", Extractor::PE32_PLUS}, 
                {"ELF", Extractor::ELF}
            };


            std::unique_ptr<Extractor::IFile> file;
            Extractor::FileFactory factory;
            file  = factory.makeFile(toEnum[static_cast<std::string>((sqlite3_column_text(stmt, 3))]);
            Extractor::FeatureSet set;
            
            set.filename = static_cast<std::string>(sqlite3_column_text(stmt, 1));
            set.fileHash = static_cast<std::size_t>(sqlite3_column_int(stmt, 2));
            set.numExeSections = static_cast<std::uint16_t>(sqlite3_column_int(stmt, 7));
            set.numSections = static_cast<std::uint16_t>(sqlite3_column_int(stmt, 8));
            set.virtualTextSizeRatio = sqlite3_column_double(stmt, 9);
            set.isMalicious = sqlite3_column_int(stmt, 5);

            file->setFeatures(set);


            rc = sqlite3_finalize(stmt);
        }
        else
        {
            std::unique_ptr<Extractor::IFile> file;
            file = std::make_unique<Extractor::PE::PEFile32>();
            file->m_filename = "Invalid";

            rc = sqlite3_finalize(stmt);
            return file;
        }
        
        //rc = sqlite3_exec(connection, "END TRANSACTION", 0, 0, 0);
    }

    bool DBManager::checkReturnCode(int returnCode, char* error)
    {
        if(returnCode != SQLITE_OK )
        {
            if(error)
                fprintf(stderr, "SQL error: %s\n", error);
            else
                std::cout << "SQL error, with no error message." << std::endl;
            
            sqlite3_free(error);
            error = nullptr;
            return false;
        }
        return true;
    }

    DBManager::~DBManager()
    {
        sqlite3_close(connection);
    }

}